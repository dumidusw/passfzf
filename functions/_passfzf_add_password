# Helper function for adding new passwords (top-level)
# Save as functions/_passfzf_add_password (no extension)

_passfzf_add_password() {
    local pass_dir="$1"
    echo "ğŸ“ Select parent folder for new password:"

    # Get directories (exclude hidden)
    local -a dirs=()
    while IFS=$'\n' read -r dir; do
        [[ -z "$dir" ]] && continue
        [[ "$dir" == .* || "$dir" == */.* ]] && continue
        dirs+=("$dir")
    done < <(find "$pass_dir" -mindepth 1 -type d -printf '%P\n' 2>/dev/null)

    local dir_count=${#dirs[@]}
    local picker_height=$((dir_count + 10))
    [[ $picker_height -lt 15 ]] && picker_height=15
    [[ $picker_height -gt 30 ]] && picker_height=30

    local selected_dir
    selected_dir=$(
        {
            echo "ğŸ“ / (top level)"
            printf '%s\n' "${dirs[@]}" | sort -u | sed 's|^|ğŸ“ |; s|$|/|'
        } | fzf --height ${picker_height} \
                --reverse \
                --prompt='ğŸ“ Folder> ' \
                --header='Select parent folder â€¢ ESC to cancel â€¢ Ctrl+N = top level' \
                --preview='
                    case {} in
                        *"(top level)"*)
                            echo "âš ï¸  You are about to add a password at the top level."
                            echo ""
                            echo "Existing entries in root:"
                            find "'"$pass_dir"'" -mindepth 1 -maxdepth 1 -name "*.gpg" -printf "%P\n" 2>/dev/null | sed "s/\.gpg$//" | sort | head -10 | sed "s/^/  ğŸ” /"
                            ;;
                        *)
                            clean=$(echo {} | sed "s/ğŸ“ //" | sed "s|/$||")
                            echo "Will create under: $clean/"
                            echo ""
                            echo "Existing entries in this folder:"
                            find "'"$pass_dir"'" -maxdepth 1 -name "*.gpg" -printf "%P\n" 2>/dev/null | sed "s/\.gpg$//" | sort | head -10 | sed "s/^/  ğŸ” /"
                            ;;
                    esac' \
                --preview-window='right:50%' \
                --bind 'ctrl-n:execute-silent(echo "ğŸ“ / (top level)")+accept'
    )

    [[ -z "$selected_dir" || "$selected_dir" == "ctrl-q" ]] && { echo "ğŸ‘‹ Goodbye!"; return 0; }

    if [[ "$selected_dir" == *"(top level)"* ]]; then
        selected_dir=""
    else
        selected_dir="${selected_dir#ğŸ“ }"
        selected_dir="${selected_dir%/}"
    fi

    exec < /dev/tty
    echo -n "âœï¸  Enter new entry name (e.g., twitter): "
    read -r new_name
    if [[ -z "$new_name" ]]; then
        echo "âŒ Aborted."
        return 1
    fi
    if [[ "$new_name" =~ [[:space:]] ]]; then
        echo "âŒ Entry name cannot contain spaces. Use underscores or hyphens instead."
        return 1
    fi

    local new_path="${selected_dir:+$selected_dir/}$new_name"
    if [[ -f "$pass_dir/$new_path.gpg" ]]; then
        echo "âŒ Entry '$new_path' already exists!"
        return 1
    fi

    local tmpfile
    tmpfile=$(mktemp -t passfzf-new-XXXXXX)
    cat > "$tmpfile" <<'EOF'
# Enter password on first line. Lines after are optional metadata (notes, username, etc.)
# DO NOT LEAVE FIRST LINE EMPTY.
# Save & quit to continue. Delete all content to cancel.
EOF

    ${EDITOR:-nvim} "$tmpfile"

    if [[ ! -s "$tmpfile" ]] || [[ -z "$(sed '/^#/d; /^$/d; q' "$tmpfile")" ]]; then
        echo "âŒ Password cannot be empty. Aborted."
        rm -f "$tmpfile"
        return 1
    fi

    local clean_tmpfile
    clean_tmpfile=$(mktemp -t passfzf-clean-XXXXXX)
    grep -v '^#' "$tmpfile" > "$clean_tmpfile"

    if pass insert -m "$new_path" < "$clean_tmpfile" &>/dev/null; then
        echo "âœ… Password created successfully: $new_name"
        command -v notify-send >/dev/null 2>&1 && {
            notify-send "ğŸ” New Password Created" "$new_name" -t 2000 -u low &>/dev/null &
            disown
        }
        echo "ğŸ”„ Reloading..."
        rm -f "$tmpfile" "$clean_tmpfile"
        passfzf
    else
        echo "âŒ Failed to create: $new_path"
        rm -f "$tmpfile" "$clean_tmpfile"
        return 1
    fi
}
